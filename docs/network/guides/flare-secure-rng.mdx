---
slug: random-number-generation
title: Flare's Secure RNG
tags: [quickstart, solidity]
authors: [dineshpinto, horiamagureanu, charlesgrover]
description: Use Flare's secure random number generator.
keywords: [solidity, randomness, random-number, smart-contract, flare-network]
sidebar_position: 6
---

import Remix from "@site/src/components/remix";
import CodeBlock from "@theme/CodeBlock";
import SecureRandomConsumer from "!!raw-loader!/examples/developer-hub-solidity/SecureRandomConsumer.sol";
import SetEvmVersionRemix from "/static/img/set-evm-version-remix.png";

This guide demonstrates how to obtain cryptographically secure random numbers on Flare. The randomness is generated from FTSOv2's [Scaling](/ftso/scaling/overview) protocol, which consists of a decentralized network of around 100 data providers that generate random numbers every 90 seconds.

You can integrate this secure randomness into your decentralized application for no cost (other than gas).

<details>
<summary>**Understand the mechanism behind Flare's Secure RNG.**</summary>

As described in the [FTSOv2 whitepaper](https://flare.network/wp-content/uploads/FTSOv2-White-Paper.pdf), the Scaling protocol consists of the following phases:

1. **Commit:** During the Commit phase, data providers prepare their submissions for each of the data feeds and encode them into a 4-byte vector. Then, each data provider publishes on chain a hash commitment obtained as:

   `Hash(address, voting_epoch_id, random_number, price_data)`

   - **Random Number**: This commit includes a locally generated random number.
   - **Purpose**: The random number blinds the commit hash of the user from a search attack and is used later (once revealed) to contribute to on-chain randomness.

2. **Reveal:** During the Reveal phase, each data provider reveals all inputs to their hash commitment. As such, all locally produced random numbers become available on-chain.

3. **Signing:** After the Reveal phase, data providers perform a number of local computations relevant to the FTSO Scaling protocol, which include:

   - Computing the weighted median prices
   - Calculating the rewards

   All these are packaged into a Merkle root, which is published on-chain together with a signature of the root.

4. **Finalization:** Once enough signatures for the same Merkle root are gathered, the process is finalized.

**Secure Random Numbers**

For each voting epoch (90 seconds), an overall random number is generated from the local random numbers:

$$
R = \sum_{i} r_i \pmod{N}
$$

where $r_i$ is the local random number generated by the $i^{th}$ data provider, and $ N = 2^n $ denotes the maximum possible size of the individual $n$-bit random numbers.
This mechanism ensures that the resultant $R$ is a uniformly generated random number as long as at least any one of the inputs was an honestly generated uniformly random number.

Importantly, The Merkle root published by the data providers contains a Boolean value that tracks whether the generated random number for the current voting epoch is secure.

**Security Mechanism**

The security mechanism behind the random number generator protects the protocol against withholding attacks. An adversary could wait until all submissions are known and then choose whether or not to reveal their own commit data to influence the final result. This security mechanism measures the quality of the random number as follows:

- **True**: If there are no omissions of reveals for the commits provided by the data providers.
- **False**: If any omission exists, or if a reveal does not match the committed value.

If a data provider causes an omission (or false reveal), they will be penalized, and their random number will not be included in the random number calculation for a number of voting rounds.

</details>

<CodeBlock language="solidity" title="SecureRandomConsumer.sol">
  {SecureRandomConsumer}
</CodeBlock>

{/* prettier-ignore */}
<Remix gist="ae30de7237444059e6fac1120ecb1630">Open in Remix</Remix>
<br></br>

In addition to the `randomNumber` itself, two other variables are retrieved:

- `isSecure`: A boolean flag indicating whether the random number was generated securely. If the protocol detects any attempt to manipulate the random number, this flag is set to `false`.

- `timestamp`: The UNIX timestamp marking the end of the voting epoch during which data was collected from data providers to generate the specific number. Each voting epoch lasts for a fixed 90-second window.

:::warning[When compiling and deploying the contract]

- **Using Remix:** Set EVM version to `london` in the **Advanced Configurations** section of the **Solidity Compiler** tab:

  <img src={SetEvmVersionRemix} style={{ width: 300 }} />

- **Using Standard Solidity JSON:** Set `evmVersion` to `london`:

  ```json
  {
    "settings": {
      "optimizer": {
        /* ... */
      },
      "evmVersion": "london"
    }
  }
  ```

- **Using `solc` CLI:** Set `--evm-version` to `london`:

  ```bash
  solc --evm-version london <args>
  ```

:::
